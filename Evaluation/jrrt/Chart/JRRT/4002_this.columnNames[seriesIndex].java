package org.jfree.data.jdbc;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Date;
import org.jfree.chart.event.DatasetChangeInfo;
import org.jfree.data.Range;
import org.jfree.data.RangeInfo;
import org.jfree.data.xy.AbstractXYDataset;
import org.jfree.data.xy.TableXYDataset;
import org.jfree.data.xy.XYDataset;

public class JDBCXYDataset extends AbstractXYDataset implements XYDataset, TableXYDataset, RangeInfo  {
  private transient Connection connection;
  private String[] columnNames = {  } ;
  private ArrayList rows;
  private double maxValue = 0.0D;
  private double minValue = 0.0D;
  private boolean isTimeSeries = false;
  private JDBCXYDataset() {
    super();
    this.rows = new ArrayList();
  }
  public JDBCXYDataset(Connection con) throws SQLException {
    this();
    this.connection = con;
  }
  public JDBCXYDataset(Connection con, String query) throws SQLException {
    this(con);
    executeQuery(query);
  }
  public JDBCXYDataset(String url, String driverName, String user, String password) throws SQLException, ClassNotFoundException {
    this();
    Class.forName(driverName);
    this.connection = DriverManager.getConnection(url, user, password);
  }
  public Comparable getSeriesKey(int seriesIndex) {
    String var_4002 = this.columnNames[seriesIndex];
    if((seriesIndex < this.columnNames.length) && (var_4002 != null)) {
      return this.columnNames[seriesIndex];
    }
    else {
      return "";
    }
  }
  public Number getX(int seriesIndex, int itemIndex) {
    ArrayList row = (ArrayList)this.rows.get(itemIndex);
    return (Number)row.get(0);
  }
  public Number getY(int seriesIndex, int itemIndex) {
    ArrayList row = (ArrayList)this.rows.get(itemIndex);
    return (Number)row.get(seriesIndex + 1);
  }
  public Range getRangeBounds(boolean includeInterval) {
    return new Range(this.minValue, this.maxValue);
  }
  public boolean isTimeSeries() {
    return this.isTimeSeries;
  }
  public double getRangeLowerBound(boolean includeInterval) {
    return this.minValue;
  }
  public double getRangeUpperBound(boolean includeInterval) {
    return this.maxValue;
  }
  public int getItemCount() {
    return getItemCount(0);
  }
  public int getItemCount(int seriesIndex) {
    return this.rows.size();
  }
  public int getSeriesCount() {
    return this.columnNames.length;
  }
  public void close() {
    try {
      this.connection.close();
    }
    catch (Exception e) {
      System.err.println("JdbcXYDataset: swallowing exception.");
    }
  }
  public void executeQuery(String query) throws SQLException {
    executeQuery(this.connection, query);
  }
  public void executeQuery(Connection con, String query) throws SQLException {
    if(con == null) {
      throw new SQLException("There is no database to execute the query.");
    }
    ResultSet resultSet = null;
    Statement statement = null;
    try {
      statement = con.createStatement();
      resultSet = statement.executeQuery(query);
      ResultSetMetaData metaData = resultSet.getMetaData();
      int numberOfColumns = metaData.getColumnCount();
      int numberOfValidColumns = 0;
      int[] columnTypes = new int[numberOfColumns];
      for(int column = 0; column < numberOfColumns; column++) {
        try {
          int type = metaData.getColumnType(column + 1);
          switch (type){
            case Types.NUMERIC:
            case Types.REAL:
            case Types.INTEGER:
            case Types.DOUBLE:
            case Types.FLOAT:
            case Types.DECIMAL:
            case Types.BIT:
            case Types.DATE:
            case Types.TIME:
            case Types.TIMESTAMP:
            case Types.BIGINT:
            case Types.SMALLINT:
            ++numberOfValidColumns;
            columnTypes[column] = type;
            break ;
            default:
            columnTypes[column] = Types.NULL;
            break ;
          }
        }
        catch (SQLException e) {
          columnTypes[column] = Types.NULL;
          throw e;
        }
      }
      if(numberOfValidColumns <= 1) {
        throw new SQLException("Not enough valid columns where generated by query.");
      }
      this.columnNames = new String[numberOfValidColumns - 1];
      int currentColumn = 0;
      for(int column = 1; column < numberOfColumns; column++) {
        if(columnTypes[column] != Types.NULL) {
          this.columnNames[currentColumn] = metaData.getColumnLabel(column + 1);
          ++currentColumn;
        }
      }
      if(this.rows != null) {
        for(int column = 0; column < this.rows.size(); column++) {
          ArrayList row = (ArrayList)this.rows.get(column);
          row.clear();
        }
        this.rows.clear();
      }
      switch (columnTypes[0]){
        case Types.DATE:
        case Types.TIME:
        case Types.TIMESTAMP:
        this.isTimeSeries = true;
        break ;
        default:
        this.isTimeSeries = false;
        break ;
      }
      while(resultSet.next()){
        ArrayList newRow = new ArrayList();
        for(int column = 0; column < numberOfColumns; column++) {
          Object xObject = resultSet.getObject(column + 1);
          switch (columnTypes[column]){
            case Types.NUMERIC:
            case Types.REAL:
            case Types.INTEGER:
            case Types.DOUBLE:
            case Types.FLOAT:
            case Types.DECIMAL:
            case Types.BIGINT:
            case Types.SMALLINT:
            newRow.add(xObject);
            break ;
            case Types.DATE:
            case Types.TIME:
            case Types.TIMESTAMP:
            newRow.add(new Long(((Date)xObject).getTime()));
            break ;
            case Types.NULL:
            break ;
            default:
            System.err.println("Unknown data");
            columnTypes[column] = Types.NULL;
            break ;
          }
        }
        this.rows.add(newRow);
      }
      if(this.rows.size() == 0) {
        ArrayList newRow = new ArrayList();
        for(int column = 0; column < numberOfColumns; column++) {
          if(columnTypes[column] != Types.NULL) {
            newRow.add(new Integer(0));
          }
        }
        this.rows.add(newRow);
      }
      if(this.rows.size() < 1) {
        this.maxValue = 0.0D;
        this.minValue = 0.0D;
      }
      else {
        ArrayList row = (ArrayList)this.rows.get(0);
        this.maxValue = Double.NEGATIVE_INFINITY;
        this.minValue = Double.POSITIVE_INFINITY;
        for(int rowNum = 0; rowNum < this.rows.size(); ++rowNum) {
          row = (ArrayList)this.rows.get(rowNum);
          for(int column = 1; column < numberOfColumns; column++) {
            Object testValue = row.get(column);
            if(testValue != null) {
              double test = ((Number)testValue).doubleValue();
              if(test < this.minValue) {
                this.minValue = test;
              }
              if(test > this.maxValue) {
                this.maxValue = test;
              }
            }
          }
        }
      }
      fireDatasetChanged(new DatasetChangeInfo());
    }
    finally {
      if(resultSet != null) {
        try {
          resultSet.close();
        }
        catch (Exception e) {
        }
      }
      if(statement != null) {
        try {
          statement.close();
        }
        catch (Exception e) {
        }
      }
    }
  }
  public void setTimeSeries(boolean timeSeries) {
    this.isTimeSeries = timeSeries;
  }
}